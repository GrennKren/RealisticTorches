package com.chaosthedude.realistictorches.blocks;

import java.util.function.ToIntFunction;
import com.chaosthedude.realistictorches.config.ConfigHandler;
import com.chaosthedude.realistictorches.registry.RealisticTorchesRegistry;
import net.minecraft.core.BlockPos;
import net.minecraft.core.particles.ParticleTypes;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.util.RandomSource;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.ItemInteractionResult;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelReader;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.LanternBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition.Builder;
import net.minecraft.world.level.block.state.properties.IntegerProperty;
import net.minecraft.world.phys.BlockHitResult;

public class RealisticLanternBlock extends LanternBlock {
    public static final String NAME = "lantern";
    public static final int TICK_INTERVAL = 2400; // 2x lebih lama dari torch
    protected static final int INITIAL_BURN_TIME = ConfigHandler.getLanternBurnoutTime();
    protected static final boolean SHOULD_BURN_OUT = INITIAL_BURN_TIME > 0;
    protected static final IntegerProperty BURNTIME = IntegerProperty.create("burntime", 0, SHOULD_BURN_OUT ? INITIAL_BURN_TIME : 1);
    protected static final IntegerProperty LITSTATE = IntegerProperty.create("litstate", 0, 2);
    public static final int LIT = 2;
    public static final int SMOLDERING = 1;
    public static final int UNLIT = 0;

    public RealisticLanternBlock() {
        super(Block.Properties.ofFullCopy(Blocks.LANTERN).lightLevel(getLightValueFromState()).randomTicks());
        registerDefaultState(stateDefinition.any().setValue(LITSTATE, 0).setValue(BURNTIME, 0));
    }

    private static ToIntFunction<BlockState> getLightValueFromState() {
        return state -> {
            int litState = state.getValue(LITSTATE);
            if (litState == LIT) return 15; // Full brightness
            if (litState == SMOLDERING) return 8; // Dim light
            return 0; // Unlit
        };
    }

    @Override
    public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
        if (state.getValue(LITSTATE) == LIT || (state.getValue(LITSTATE) == SMOLDERING && level.getRandom().nextInt(2) == 1)) {
            if (state.getValue(LITSTATE) == LIT) {
                level.addParticle(ParticleTypes.FLAME, pos.getX() + 0.5D, pos.getY() + 0.7D, pos.getZ() + 0.5D, 0.0D, 0.0D, 0.0D);
            } else {
                level.addParticle(ParticleTypes.SMOKE, pos.getX() + 0.5D, pos.getY() + 0.7D, pos.getZ() + 0.5D, 0.0D, 0.0D, 0.0D);
            }
        }
    }

    @Override
    protected ItemInteractionResult useItemOn(ItemStack stack, BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
        if (level.isClientSide()) {
            return ItemInteractionResult.SUCCESS;
        }

        // Check if item can light lantern
        String itemId = BuiltInRegistries.ITEM.getKey(stack.getItem()).toString();
        boolean canLight = stack.getItem() == Items.FLINT_AND_STEEL ||
                stack.getItem() == RealisticTorchesRegistry.MATCHBOX_ITEM.get() ||
                ConfigHandler.getLightLanternItems().contains(itemId);

        // Check if item is fuel for refilling
        boolean isFuel = ConfigHandler.getLanternFuelItems().contains(itemId);

        if (canLight && state.getValue(LITSTATE) == UNLIT) {
            playLightingSound(level, pos);
            if (!player.isCreative() && (stack.getItem() != RealisticTorchesRegistry.MATCHBOX_ITEM.get() || ConfigHandler.getMatchboxDurability() > 0)) {
                stack.hurtAndBreak(1, player, LivingEntity.getSlotForHand(hand));
            }
            changeToLit(level, pos, state);
            return ItemInteractionResult.SUCCESS;
        } else if (isFuel && state.getValue(LITSTATE) != UNLIT) {
            // Refuel lantern
            int currentBurnTime = state.getValue(BURNTIME);
            if (currentBurnTime < INITIAL_BURN_TIME) {
                playRefuelSound(level, pos);
                if (!player.isCreative()) {
                    stack.shrink(1);
                }
                level.setBlock(pos, state.setValue(BURNTIME, Math.min(currentBurnTime + ConfigHandler.getLanternFuelAmount(), INITIAL_BURN_TIME)), 2);
                return ItemInteractionResult.SUCCESS;
            }
        }

        return super.useItemOn(stack, state, level, pos, player, hand, hit);
    }

    @Override
    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
        if (!level.isClientSide() && SHOULD_BURN_OUT && state.getValue(LITSTATE) > UNLIT) {
            int newBurnTime = state.getValue(BURNTIME) - 1;
            if (newBurnTime <= 0) {
                playExtinguishSound(level, pos);
                changeToUnlit(level, pos, state);
                level.updateNeighborsAt(pos, this);
            } else if (state.getValue(LITSTATE) == LIT && (newBurnTime <= INITIAL_BURN_TIME / 10 || newBurnTime <= 1)) {
                changeToSmoldering(level, pos, state, newBurnTime);
                level.updateNeighborsAt(pos, this);
            } else {
                level.setBlock(pos, state.setValue(BURNTIME, newBurnTime), 2);
                level.scheduleTick(pos, this, TICK_INTERVAL);
            }
        }
    }

    @Override
    public void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
        if (level.isRainingAt(pos) && state.getValue(LITSTATE) > UNLIT && ConfigHandler.getLanternRainExtinguish()) {
            if (random.nextFloat() < 0.1f) { // 10% chance to extinguish in rain
                playExtinguishSound(level, pos);
                changeToUnlit(level, pos, state);
            }
        }
    }

    @Override
    public void setPlacedBy(Level level, BlockPos pos, BlockState state, LivingEntity entity, ItemStack stack) {
        super.setPlacedBy(level, pos, state, entity, stack);
        level.scheduleTick(pos, this, TICK_INTERVAL);
    }

    @Override
    protected void createBlockStateDefinition(Builder<Block, BlockState> builder) {
        super.createBlockStateDefinition(builder);
        builder.add(BURNTIME, LITSTATE);
    }

    @Override
    public ItemStack getCloneItemStack(LevelReader level, BlockPos pos, BlockState state) {
        boolean lit = state.getValue(LITSTATE) == LIT;
        if (!lit) {
            return new ItemStack(RealisticTorchesRegistry.UNLIT_LANTERN_ITEM.get());
        }
        return new ItemStack(RealisticTorchesRegistry.LIT_LANTERN_ITEM.get());
    }

    public static IntegerProperty getBurnTime() {
        return BURNTIME;
    }

    public static IntegerProperty getLitState() {
        return LITSTATE;
    }

    public static int getInitialBurnTime() {
        return SHOULD_BURN_OUT ? INITIAL_BURN_TIME : 0;
    }

    public void changeToLit(Level level, BlockPos pos, BlockState state) {
        level.setBlock(pos, RealisticTorchesRegistry.LANTERN_BLOCK.get().defaultBlockState()
                .setValue(LITSTATE, LIT)
                .setValue(BURNTIME, getInitialBurnTime()), 2);
        if (SHOULD_BURN_OUT) {
            level.scheduleTick(pos, this, TICK_INTERVAL);
        }
    }

    public void changeToSmoldering(Level level, BlockPos pos, BlockState state, int newBurnTime) {
        if (SHOULD_BURN_OUT) {
            level.setBlock(pos, RealisticTorchesRegistry.LANTERN_BLOCK.get().defaultBlockState()
                    .setValue(LITSTATE, SMOLDERING)
                    .setValue(BURNTIME, newBurnTime), 2);
            level.scheduleTick(pos, this, TICK_INTERVAL);
        }
    }

    public void changeToUnlit(Level level, BlockPos pos, BlockState state) {
        level.setBlock(pos, RealisticTorchesRegistry.LANTERN_BLOCK.get().defaultBlockState()
                .setValue(LITSTATE, UNLIT)
                .setValue(BURNTIME, 0), 2);
    }

    private void playLightingSound(Level level, BlockPos pos) {
        level.playSound(null, pos, SoundEvents.FLINTANDSTEEL_USE, SoundSource.BLOCKS, 1.0F, 1.0F);
    }

    private void playExtinguishSound(Level level, BlockPos pos) {
        level.playSound(null, pos, SoundEvents.FIRE_EXTINGUISH, SoundSource.BLOCKS, 0.5F, 1.0F);
    }

    private void playRefuelSound(Level level, BlockPos pos) {
        level.playSound(null, pos, SoundEvents.BOTTLE_FILL, SoundSource.BLOCKS, 0.8F, 1.0F);
    }
}